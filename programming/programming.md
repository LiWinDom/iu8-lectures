# Компьютер. Языки программирования

> **Компьютер** - устройство, способное выполнять заданную, чётко определённую, изменяемую последовательность операций.

> **Электронно-вычислетальная машина (ЭВМ)** - основной вид реализации компьютеров, который технически выполнен на электронных компонентах.

## Элементарные термины

> **Процессор** - интегральная схема, использующая машинные инструкции (код программы), главная часть аппаратного обеспечения компьютера.

> **Машинный код** - система команд (набор готовых инструкций) конкретной вычислительной машины, которая интепретируется непосредственно процессором. Кодируется в двоичном видe.

> **Файл** - наименованное место на диске.

> **Алгоритм** - конечная совокупность точно заданных правил решения некоторого класса задач или набор инструкций, описывающих порядок действий исполнителя для решения определенной задачи.

> **Исполняемая программа** - сочетание компьютерных инструкций и данных, позволяющее аппаратному обеспечению вычислительной системы выполнять вычисления или функции управления.

> **Язык программирования** - формальный язык, предназначенный для записи компьютерных программ. Язык программирования определяет набор лексических, синтаксических и семантических правил, определяющих действия, которые выполнит ЭВМ под ее управлением.

> **Исполняемый файл** - файл, содержащий программу в том виде, в котором она может выполнена компьтером (т.е. в машинном коде).

Получение исполняемых файлов требует выполнения _компиляции_.

> **Компилятор** - программа для преобразования исходного текста другой программы на определённом языке в объектный модуль (файл с машинным кодом).

## Способы классификации языков программирования

Уровень абстракции от аппаратной части:
- Низкоуровневые
- Высокоуровневые

Способ выполнения готовой программы:
- Интепретируемые
- Компилируемые

Используемая парадигма:
- Императивные (процедурные)
- Аппликативные (функциональные) 
- Системы правил (декларативные)
- Объектно-ориентированные

# Язык программирования Python

> **Python** - высокоуровневый язык программирования общего назначения. Интепретируемый. Является полностью объектно-ориентированным.

Программа -> Модули -> Операторы -> Выражения -> Лексемы.

> **Лексема** - минимальная единица языка, имеющая самостоятельный смысл.

Пять типов лексем:
1. Ключевые слова
2. Идентификаторы
3. Литералы
4. Операции
5. Знаки пунктуации

### Строки программы
> **Физическая строка** исходного файла - строка, заканчивающаяся символом конца строки.

Программы Python разделены на несколько логических строк. **Логическая строка** содержит одну или несколько _физических строк_, соединяющихся правилами языка.

Ведущие пробельные символы (пробелы и табуляции) в начале строки используются в Python для определения группы инструкций, как единого целого, составной инструмент или блока.

## Правила оформления кода на Python

Текст программы должен начинаться с комментария, в котором указано:
1. Назначение программы
2. Автор

Исходный код программы должен делиться на три блока:
1. Блок ввода данных
2. Блок вычислений
3. Блок вывода данных

Также не менее важно:
- Программный код должен быть подробно закомментирован
- Программа должна выдавать корректный ответ при корректных входных данных.
- При выводе числовых значений выводить 5-7 значащих цифр (форматирование `:g`).
- При вводе данных должно быть приглашение.
- Если требуется ввод нескольких переменных в одной строке, то необходимо указать, какой разделитель используется.
- Исходный код должен оформляться согласно стандарту PEP-8 (будут бить).
- За транслит тоже будут бить.
- Строка должна быть не более 80 символов.
- Большие числа выводить в инженерном виде.

## Типы данных

> **Данные** - поддающееся многократной интепретацией представление информации в формализованном виде, пригодном для передачи, связи или обработки.

> **Тип данных** - множество значений и операций над этими значениями.

Основные способы классификации даннхы:
- Скалярные и нескалярные
- Самостоятельные и зависимые (в том числе ссылочные)

Примеры самостоятельных скалярных типов:
- Целые
- Логические

Примеры нескалярных типов: 
- Массивы
- Списки
- Структуры.

Основные типы данных Python
- Числа
- Строки
- Списки
- Словари
- Кортежи
- Файлы
- Множества
- Булевы (True/False)

## Переменные

> **Переменная** - проименованная область памяти, которую можно использовать для хранения данных, а её значение можно изменять в ходе выполнения программы.

> **Имя переменной** - строка символов, которая её идентифицирует (отличает от других переменных и объектов программы).

Идентификаторы в Python:
- Заглавные и строчные символы латиницы
- Цифры
- Символ нижнего подчёркивания

### Числовые типы данных

Числовые данные в Python делятся на:
- Целые
- С плавающей запятой
- Комплексные
- Десятичные с фиксированной точностью
- Рациональные дроби

#### Операции над числами

Приоритеты:
1. Возведение в степень
2. Умножение, деление, взятие остатка
3. Сложение, вычитание
4. Побитовое И
5. Побитовое исключающее ИЛИ
6. Побитовое ИЛИ

### Логический тип данных (`bool`)

Принимает два значения:
- `True`
- `False`

0 -> False
Любое другое значение -> True

#### Сравнение чисел с плавающей запятой

```py
a, b: float

# Wrong:
a == b

# Correct:
eps = 1e-8
abs(a - b) < eps
```

### Приоритеты логических операций

1. Арифмитические побитовые
2. Сравнение
3. Логические

Важно! Лишние скобочки ухудшают читабельность кода, за это будут бить на лабах!

#### Примеры применения условного оператора

```py
if x < y:
    print("x < y")
elif x == y:
    print("x = y")
else:
    print("x > y")
```

#### Тернарный оператор

```py
# This...
res = x if condition else y

# ... is equivalent that:
if condition:
  res = x
else:
  res = y
```

#### NoneType, None

`None` - специальное значение типа `NoneType`, соответствующее "пустому" значению.

#### Оператор проверки идентичности:
```py
# Wrong:
x == None
y != None

# Correct:
x is None
y is not None
```

### Циклы

> **Циклы** - разновидность упарвляющей конструкции в высокоуровневных языках программирования, предназначенная для организации многократного исполнения набора инструкций.

В `python` есть два типа циклов:
```py
while condition:
    # some code..
```
И 
```py
for iterator in iterable:
    # some code...
```

Примеры:
```py
while x > 0:
  x -= 1
```

```py
for i in range(begin, end+1, step):
    print(i)
```

```py
for i in range(s):
    print(i)
```

#### Оператор `break`

Переходит за пределы ближайшего цикла.

#### Оператор `continue`

Переходит к начало ближайшего цикла (в сторону заголовка цикла).

#### Оператор `pass`

Ничего не делает. Просто заполняет пустоту.
Например, можно использовать как "заглушку":
```py
if condition:
    pass

# some code...
```

#### Часть `else`

Выполняется если цикл был завершён без прерывания `break`.
Позволяет устранить потребность в дополнительных флагах состояния.

#### Вложенные циклы

Вложенным цикл называется цикл, организованный внутри тела другого цикла:

```py
for i in range(1, 10):      # Outer loop
    for j in range(1, 10):  # Nested loop
        print("i x j = {}".format(i*j), end=0)
```

#### Оператор `:=`

Оператор "морж" `:=` - присваивает и возвращает значение одновременно.

### Модуль `time`

Предоставляет функции для работы со временем.

```py
import time
time.sleep(5)    # Wait 5 seconds...
```

Время эпохи `UNIX` - количество секунд, прошедшее с `01.01.1970 00:00:00+00`

```py
import time
print(time.time())   # Return UNIX-time
```

# Схемы алгоритмов

> `ГОСТ 19.701-90` \
> _Схемы алгоритмов программ, данных и систем. Условные обозначения и правила выполнения_.

# Про вычисление рядов

Есть некоторая точность, до которой мы считаем ряд. В таком случае считаем ряд _сходящимся_.

Если ряд не сходится - добавляем ограничение на количество итераций.

Пару примеров:

$$
\sum_{i=1}^{\infty} \frac{1}{x!}
$$

Равносильно коду:

```py
from math import factorial

EPS = 1e-5

el = 1
s = el
i = 1

# WRONG!
while abs(el) > EPS:
    i += 1
    el = 1 / factorial(i)
    s += el
```

Однако данный алгоритм не эффективен. Можно задать последовательность через реккурентную форму.

```py
# RIGHT
while abs(el) > EPS:
    i += 1
    el /= i
    s += el
```

# Коллекции данных

> **Коллекция** - объект, содержащий в себе набор значений одного или различного типов и позволяющий обращаться к этим значениям.

## Основные виды

1. Массив
   - Одномерный (вектор)
   - Двумерный (матрица)
   - Многомерный
2. Список
3. Ассоциативный массив, очередь, стек, множество

> ВАЖНО! В Python *нет* массивом - есть *списки*! За это будут бить.

Однако есть исключение - модуль `array`.

## Вычислительная сложность

> **Вычислительная сложность** - понятие в теории алгоритмов, обозначающее функцию зависимости объёма работы (по времени или памяти), которая выполняется некоторым алгоритмов, от размера входных данных.

### Основные виды:

1. O(n) - линейная
2. O(n^2) - квадратичная
3. O(log n) - логарифмическая
4. O(n log n)

## Реализация коллекций в Python3

Неизменяемые (immutable)
- `range`
- `tuple` - кортеж

Изменяемые (mutable)
- `list` - список
- `set` - множество
- `dict` - словарь

## Списки

Создание списка:
```py
numbers = [1, 2, 3, 5, 6, 8, 4, 2]
numbers = list()
```

Индексация с 0. \
Обращение к элементам:
```py
numbers[4]      # 6
numbers[-1]     # 2
```

### Функции работы со списками

- `all` - вернёт `True`, если все значение истинны
- `enumerate` 
- `len` - кол-во элементов в списке
- `print` - выводит в консоль список
- `max` - возвращает максимальное хначние
- `min`
- `reversed`
- `sorted`
- `sum`

### Некоторые понятия ООП

> **Класс** - некоторый шаблон для создания объектов, обеспечивающий начальные значения состояния, инициализация полей-переменных и реализация поведения методов.

> **Объект** - экземпляр класса с собственным состоянием этих свойств.

> **Поле** - некоторое свойство или аттрибут какого-то объекта. Объявляется в классе.

> **Метод** - функция объекта, которая имеет доступ к его состоянию (полям). Реализуется в классе.

### Методы работы со списками

- `append` - добавить элмент в конец
- `extend` - расширить один список другим
- `insert` - вставить значение по индексу
- `remove` - удаление по значению
- `pop` - удаление по индексу
- `clear` - очистить список
- `index` - определить индекс элемента
- `count` - кол-во элементов в списке
- `sort` - сортирует список
- `reverse` - инвертирует список
- `copy` - поверхностное копирование списка

### Операторы для работы со списками

- `+` - конкатенация списков (соединение)
- `*` - увеличить длину списка, скопировав элементы
- `in` - принадлежность значения списку
- `del` - удаление переменной или элемента
- `==` - сравнение списков на совпадение элементов с учётом порядка
- `>`, `>=`, `<`, `<=` - сравнение списков с учётом лексикографического порядка элементов
- `for i in list: ...`

### Про копирование списков

```py
x = [1, 2, 3]

y = x
print(x is y)   # True

z = x.copy()
print(z is x)   # False
```

Т.е. `y` - это ссылка на тот же список `x`. Изменяя `x`, изменяется и `y`.
Чтобы именно _копировать_, нужно использовать метод `.copy()`.

### Срезы

`[start:stop:step]` - возвращает элементы списка с индекса `start`  до `stop` с шагом `step`.

```py
a = [5, 7, 8, 9]

a[:]    # [5, 7, 8, 9]
a[2:]   # [8, 9]
a[:2]   # [5, 7]
a[::-1] # [9, 8, 7, 5]
```

### Создание списков

```py
a = []

a = [0] * 5     # [0, 0, 0, 0, 0]

a = [ i*i for i in range(5) ]   # [0, 1, 4, 9, 16]

a = [ i*i for i in range(5) if i % 2 == 0 ] # [0, 4, 16]
```

### Способы ввода списков

1. Через `map`

```py
l = list(map(int, input("Введите массив числе через пробел").split(" ")))
```

2. С указанием размера

```py
n = int(input("Введите размер массива: "))
l = [0] * n
print("Последовательно вводите элементы массива: ")
for i in range(n):
    l[i] = int(input())
```

3. Без размерности и без генератора


```py
l = list()
print("Последовательно вводите элементы массива: ")
while True:
    el = int(input())
    if el:
        l.append(el)
    else:
        break
```

### Способы вывода списков

```py
l = [ ... ]

# Only for debug!
print(l)

# Right:
for i, el in enumerate(l):
    print(f"{i}-ный элемент массива: {el}")
```

# Псевдослучайные числа

Источники случайных чисел - физические шумы (сложно и дорого)

**Псевдослучайные числа** - вырабатываемые алгоритмически последовательность чисел, обладающей свойствами случайных чисел и использующиеся взамен последних при решение на ЭВМ ряда задач.

**Генератор псевдослучайных чисел** - алгоритм, порождающий последовательность чисел, элементы которой почти независимы друг от друга и подчиняются распределению (обычно - равномерному).

### Требования к ГПСЧ

- Длинный период 
- Эффективность
- Вопроизводимость

### Недостатки ГСПЧ

- Периодичность
- Зависимость значений

## Модуль `random`

Реализует генерацию псевдослучайных чисел различных распрделений.

Числовые функции:
- `randrange(stop)`, `randrange(start, stop, step)`
- `randint(a, b)` равноценно `ranrange(a, b+1)`

# Кортежи, множества и словари

Функция `id` - идентификатор объекта. Определяте

## Кортежи (`tuple`)

Кортеж - неизменяемая последовательность.

* *Операторы* - `in`, `not in`
* *Создание* - `tuple()`, `(1, 2)`
* *Функции* - как у списков
* *Методы* - `index()` и `count()`

## Словари (`dict`)

Словари - неупорядоченные коллекции произвольных объектов с доступом по ключу. Аналоги в других языках: ассоциативные массимы и хеш-таблицы.

> Ключи должны быть _хэщируемыми_ (метод `__hash__`) и сравнивыми (метод `__eq__`)!

* *Создание* 
  * `dict()`
  * `{ "key": value }`
  * `dict(("key1", value1), ("key2", value2))`
  * `{ a: a**2 for a in range(7) }`
  * `dict.fromkeys(["key1", "key2"], value)`

### Методы словарей

* `clear()` - очищает словарь
* `copy()` - создает неглубокую копию
* `fromkeys(iterable[, value])` - создает словарь на основе ключей и одного значения по умолчанию
* `get(key[, default])` - возвращает значение по ключу, если есть, или `default`, если нет
* `items()` - возвращает пары ключ-значение
* `keys()` - возвращает только ключи
* `pop(key[, default])` - удаляет и возвращает значение по ключу если существует или возвращает `default`
* `popitem()` - удаляет и возвращает последнюю добавленную пару
* `setdefault(key[, default])` - значение по умолчанию для метода `get()`
* `update(other)` - обновляет значения по другому словарю
* `values()` - возвращает только значения

## Множества: `set` и `frozenset`

> Элементы должны быть хэшируемыми!

* *Создание* - `set(), { 1, 2, 3 }`
* *Операторы* - `in`, `not in`, `<`, `<=`, `>=`, `>`, `|`, `&`, `-`, `^`
  * *Только для `set`* - `|=`, `&=`, `-=`, `^=`
* *Функции* - `len(s)`

### Методы множеств

* `isdisjoin(other)`
* `issubset(other)`
* `issuperset(other)`
* `union(*others)`
* `intersection(*others)`
* `difference(*others)`
* `symmetric_difference(other)`
* `copy()`

# Строковый тип данных

**Строка** - тип данных, значениями которого является произвольная последовательность символов. Обычно реализуется как массив символов.

* *Создание*
  * `"some text"`
  * `'some text'`
  * `"""a lot
  
    of text"""``

  * `str(object)`

## Методы работы со строками

* `capitalize()` - 
* `casefold()`
* `center()`
* `count()`
* `encode()`
* `endswith()`
* `expandtabs()`
* `find()`
* `format()`


